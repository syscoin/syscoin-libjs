/**
 * Syscoin API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.3
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import '../rxjs-operators';

import { Account } from '../model/account';
import { AddMultisigAddressRequest } from '../model/addMultisigAddressRequest';
import { EncryptWalletRequest } from '../model/encryptWalletRequest';
import { ErrorResponse } from '../model/errorResponse';
import { GetBlockResponse } from '../model/getBlockResponse';
import { GetBlockchainInfoResponse } from '../model/getBlockchainInfoResponse';
import { GetNewAddressRequest } from '../model/getNewAddressRequest';
import { ImportAddressRequest } from '../model/importAddressRequest';
import { ImportPrivKeyRequest } from '../model/importPrivKeyRequest';
import { ImportPubKeyRequest } from '../model/importPubKeyRequest';
import { ImportWalletRequest } from '../model/importWalletRequest';
import { Info } from '../model/info';
import { ListSinceBlockResponse } from '../model/listSinceBlockResponse';
import { MiningInfo } from '../model/miningInfo';
import { MoveRequest } from '../model/moveRequest';
import { PeerInfoResponse } from '../model/peerInfoResponse';
import { SendFromRequest } from '../model/sendFromRequest';
import { SendManyRequest } from '../model/sendManyRequest';
import { SendToAddressRequest } from '../model/sendToAddressRequest';
import { SignMessageRequest } from '../model/signMessageRequest';
import { Transaction } from '../model/transaction';
import { TransactionListEntry } from '../model/transactionListEntry';
import { ValidateAddressResponse } from '../model/validateAddressResponse';
import { WalletInfo } from '../model/walletInfo';
import { WalletPassphraseChangeRequest } from '../model/walletPassphraseChangeRequest';
import { WalletPassphraseRequest } from '../model/walletPassphraseRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { AddressGrouping } from "../model/addressGrouping";


@Injectable()
export class GeneralService {

    protected basePath = 'http://localhost:8001';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
			this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     *
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     *
     * Add a nrequired-to-sign multisignature address to the wallet. Each key is a Syscoin address or hex-encoded public key. If &#39;account&#39; is specified (DEPRECATED), assign address to that account.
     * @param request
     */
    public addmultisigaddress(request: AddMultisigAddressRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.addmultisigaddressWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Reveals the private key corresponding to &#39;syscoinaddress&#39;. Then the importprivkey can be used with this output.
     * @param address The syscoin address for the private key
     */
    public dumpprivkey(address: string, extraHttpRequestParams?: any): Observable<string> {
        return this.dumpprivkeyWithHttpInfo(address, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Dumps all wallet keys in a human-readable format.
     * @param filename The filename
     */
    public dumpwallet(filename: string, extraHttpRequestParams?: any): Observable<string> {
        return this.dumpwalletWithHttpInfo(filename, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Encrypts the wallet with &#39;passphrase&#39;. This is for first time encryption. After this, any calls that interact with private keys such as sending or signing will require the passphrase to be set prior the making these calls. Use the walletpassphrase call for this, and then walletlock call. If the wallet is already encrypted, use the walletpassphrasechange call. Note that this will shutdown the server.
     * @param request
     */
    public encryptwallet(request: EncryptWalletRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.encryptwalletWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED. Returns the account associated with the given address.
     * @param syscoinaddress The syscoin address for account lookup.
     */
    public getaccount(syscoinaddress: string, extraHttpRequestParams?: any): Observable<string> {
        return this.getaccountWithHttpInfo(syscoinaddress, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED. Returns the current Syscoin address for receiving payments to this account.
     * @param account The account name for the address. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.
     */
    public getaccountaddress(account: string, extraHttpRequestParams?: any): Observable<string> {
        return this.getaccountaddressWithHttpInfo(account, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED. Returns the list of addresses for the given account.
     * @param account
     */
    public getaddressesbyaccount(account: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.getaddressesbyaccountWithHttpInfo(account, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * If account is not specified, returns the server&#39;s total available balance. If account is specified (DEPRECATED), returns the balance in the account. Note that the account \&quot;\&quot; is not the same as leaving the parameter out. The server total may be different to the balance in the default \&quot;\&quot; account.
     * @param account DEPRECATED. The selected account, or \&quot;*\&quot; for entire wallet. It may be the default account using \&quot;\&quot;.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeWatchonly Also include balance in watchonly addresses (see &#39;importaddress&#39;)
     */
    public getbalance(account?: string, minconf?: number, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<number> {
        return this.getbalanceWithHttpInfo(account, minconf, includeWatchonly, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * ï»¿If verbose is false, returns a string that is serialized, hex-encoded data for block &#39;hash&#39;. If verbose is true, returns an Object with information about block &lt;hash&gt;.
     * @param hash
     * @param verbose
     */
    public getblock(hash: string, verbose?: boolean, extraHttpRequestParams?: any): Observable<GetBlockResponse> {
        return this.getblockWithHttpInfo(hash, verbose, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns an object containing various state info regarding block chain processing.
     */
    public getblockchaininfo(extraHttpRequestParams?: any): Observable<GetBlockchainInfoResponse> {
        return this.getblockchaininfoWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns the number of blocks in the longest block chain.
     */
    public getblockcount(extraHttpRequestParams?: any): Observable<number> {
        return this.getblockcountWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns an object containing various state info.
     */
    public getinfo(extraHttpRequestParams?: any): Observable<Info> {
        return this.getinfoWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns a json object containing mining-related information.
     */
    public getmininginfo(extraHttpRequestParams?: any): Observable<MiningInfo> {
        return this.getmininginfoWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns a new Syscoin address for receiving payments. If &#39;account&#39; is specified (DEPRECATED), it is added to the address book so payments received with the address will be credited to &#39;account&#39;.
     * @param request
     */
    public getnewaddress(request?: GetNewAddressRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.getnewaddressWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns data about each connected network node as a json array of objects.
     */
    public getpeerinfo(extraHttpRequestParams?: any): Observable<PeerInfoResponse> {
        return this.getpeerinfoWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED. Returns the total amount received by addresses with &lt;account&gt; in transactions with at least [minconf] confirmations.
     * @param account The selected account, may be the default account using \&quot;\&quot;.
     * @param minconf Only include transactions confirmed at least this many times.
     */
    public getreceivedbyaccount(account: string, minconf?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.getreceivedbyaccountWithHttpInfo(account, minconf, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns the total amount received by the given syscoinaddress in transactions with at least minconf confirmations.
     * @param syscoinaddress The syscoin address for transactions.
     * @param minconf Only include transactions confirmed at least this many times.
     */
    public getreceivedbyaddress(syscoinaddress: string, minconf?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.getreceivedbyaddressWithHttpInfo(syscoinaddress, minconf, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Get detailed information about in-wallet transaction &lt;txid&gt;
     * @param txid The transaction id
     * @param includeWatchonly Whether to include watchonly addresses in balance calculation and details[]
     */
    public gettransaction(txid: string, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Transaction> {
        return this.gettransactionWithHttpInfo(txid, includeWatchonly, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns the server&#39;s total unconfirmed balance
     */
    public getunconfirmedbalance(extraHttpRequestParams?: any): Observable<number> {
        return this.getunconfirmedbalanceWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns a new Syscoin (starts with 1) address for receiving payments. If &#39;account&#39; is specified (DEPRECATED), it is added to the address book so payments received with the address will be credited to &#39;account&#39;.
     * @param account DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.
     */
    public getv2address(account?: string, extraHttpRequestParams?: any): Observable<string> {
        return this.getv2addressWithHttpInfo(account, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns wallet balance for all accounts. Does not include watch only accounts.
     */
    public getwalletbalance(extraHttpRequestParams?: any): Observable<number> {
        return this.getwalletbalanceWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns an object containing various wallet state info.
     */
    public getwalletinfo(extraHttpRequestParams?: any): Observable<WalletInfo> {
        return this.getwalletinfoWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns a new ZCash address for receiving payments in ZCash transaparent tokens. so payments received with the address will be credited to &#39;account&#39;.
     * @param address
     */
    public getzaddress(address: string, extraHttpRequestParams?: any): Observable<WalletInfo> {
        return this.getzaddressWithHttpInfo(address, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Adds a script (in hex) or address that can be watched as if it were in your wallet but cannot be used to spend.
     * @param request
     */
    public importaddress(request: ImportAddressRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.importaddressWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Adds a private key (as returned by dumpprivkey) to your wallet.
     * @param request
     */
    public importprivkey(request: ImportPrivKeyRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.importprivkeyWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Imports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.
     * @param rawtransaction
     * @param txoutproof
     */
    public importprunedfunds(rawtransaction: string, txoutproof: string, extraHttpRequestParams?: any): Observable<string> {
        return this.importprunedfundsWithHttpInfo(rawtransaction, txoutproof, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Adds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend.
     * @param request
     */
    public importpubkey(request: ImportPubKeyRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.importpubkeyWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Imports keys from a wallet dump file (see dumpwallet).
     * @param request
     */
    public importwallet(request: ImportWalletRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.importwalletWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED. Returns Object that has account names as keys, account balances as values.
     * @param minconf Only include transactions with at least this many confirmations
     * @param includeWatchonly Include balances in watchonly addresses (see &#39;importaddress&#39;)
     */
    public listaccounts(minconf?: number, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<any> {
        return this.listaccountsWithHttpInfo(minconf, includeWatchonly, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Lists groups of addresses which have had their common ownership made public by common use as inputs or as the resulting change in past transactions
     */
    public listaddressgroupings(extraHttpRequestParams?: any): Observable<Array<Array<AddressGrouping>>> {
        return this.listaddressgroupingsWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED. List balances by account.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeempty Whether to include accounts that haven&#39;t received any payments.
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     */
    public listreceivedbyaccount(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Array<Account>> {
        return this.listreceivedbyaccountWithHttpInfo(minconf, includeempty, includeWatchonly, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * List balances by receiving address.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeempty Whether to include accounts that haven&#39;t received any payments.
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     */
    public listreceivedbyaddress(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Array<Account>> {
        return this.listreceivedbyaddressWithHttpInfo(minconf, includeempty, includeWatchonly, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Get all transactions in blocks since block [blockhash], or all transactions if omitted
     * @param blockhash The block hash to list transactions since
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     * @param targetConfirmations
     */
    public listsinceblock(blockhash?: string, includeWatchonly?: boolean, targetConfirmations?: number, extraHttpRequestParams?: any): Observable<Array<ListSinceBlockResponse>> {
        return this.listsinceblockWithHttpInfo(blockhash, includeWatchonly, targetConfirmations, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Returns up to &#39;count&#39; most recent transactions skipping the first &#39;from&#39; transactions for account &#39;account&#39;.
     * @param account DEPRECATED. The account name. Should be \&quot;*\&quot;.
     * @param count The number of transactions to return
     * @param from The number of transactions to skip
     * @param includeWatchonly Include transactions to watchonly addresses (see &#39;importaddress&#39;)
     */
    public listtransactions(account?: string, count?: number, from?: number, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Array<TransactionListEntry>> {
        return this.listtransactionsWithHttpInfo(account, count, from, includeWatchonly, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED. Move a specified amount from one account in your wallet to another.
     * @param request
     */
    public move(request: MoveRequest, extraHttpRequestParams?: any): Observable<boolean> {
        return this.moveWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Deletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will effect wallet balances.
     * @param txid
     */
    public removeprunedfunds(txid: string, extraHttpRequestParams?: any): Observable<string> {
        return this.removeprunedfundsWithHttpInfo(txid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * DEPRECATED (use sendtoaddress). Sent an amount from an account to a syscoin address. The amount is a real and is rounded to the nearest 0.00000001. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public sendfrom(request: SendFromRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.sendfromWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Send multiple times. Amounts are double-precision floating point numbers. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public sendmany(request: SendManyRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.sendmanyWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Send an amount to a given address. The amount is a real and is rounded to the nearest 0.00000001. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public sendtoaddress(request: SendToAddressRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.sendtoaddressWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Sign a message with the private key of an address. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public signmessage(request: SignMessageRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.signmessageWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Decode raw syscoin transaction (serialized, hex-encoded) and display information pertaining to the service that is included in the transactiion data output(OP_RETURN)
     * @param alias
     * @param hexstring
     */
    public syscoindecoderawtransaction(alias: string, hexstring: string, extraHttpRequestParams?: any): Observable<string> {
        return this.syscoindecoderawtransactionWithHttpInfo(alias, hexstring, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Sign inputs for raw transaction (serialized, hex-encoded) and sends them out to the network if signing is complete
     * @param hexstring
     */
    public syscoinsignrawtransaction(hexstring: string, extraHttpRequestParams?: any): Observable<string> {
        return this.syscoinsignrawtransactionWithHttpInfo(hexstring, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Return information about the given syscoin address.
     * @param syscoinaddress
     */
    public validateaddress(syscoinaddress: string, extraHttpRequestParams?: any): Observable<ValidateAddressResponse> {
        return this.validateaddressWithHttpInfo(syscoinaddress, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Verify a signed message
     * @param syscoinaddress The syscoin address to use for the signature.
     * @param signature The signature provided by the signer in base 64 encoding (see signmessage).
     * @param message The message that was signed.
     */
    public verifymessage(syscoinaddress: string, signature: string, message: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.verifymessageWithHttpInfo(syscoinaddress, signature, message, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Removes the wallet encryption key from memory, locking the wallet. After calling this method, you will need to call walletpassphrase again before being able to call any methods which require the wallet to be unlocked.
     */
    public walletlock(extraHttpRequestParams?: any): Observable<string> {
        return this.walletlockWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Stores the wallet decryption key in memory for &#39;timeout&#39; seconds. This is needed prior to performing transactions related to private keys such as sending syscoins
     * @param request
     */
    public walletpassphrase(request: WalletPassphraseRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.walletpassphraseWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *
     * Changes the wallet passphrase from &#39;oldpassphrase&#39; to &#39;newpassphrase&#39;.
     * @param request
     */
    public walletpassphrasechange(request: WalletPassphraseChangeRequest, extraHttpRequestParams?: any): Observable<string> {
        return this.walletpassphrasechangeWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     *
     * Add a nrequired-to-sign multisignature address to the wallet. Each key is a Syscoin address or hex-encoded public key. If &#39;account&#39; is specified (DEPRECATED), assign address to that account.
     * @param request
     */
    public addmultisigaddressWithHttpInfo(request: AddMultisigAddressRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/addmultisigaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling addmultisigaddress.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Reveals the private key corresponding to &#39;syscoinaddress&#39;. Then the importprivkey can be used with this output.
     * @param address The syscoin address for the private key
     */
    public dumpprivkeyWithHttpInfo(address: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dumpprivkey';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling dumpprivkey.');
        }
        if (address !== undefined) {
            queryParameters.set('address', <any>address);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Dumps all wallet keys in a human-readable format.
     * @param filename The filename
     */
    public dumpwalletWithHttpInfo(filename: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dumpwallet';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'filename' is not null or undefined
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling dumpwallet.');
        }
        if (filename !== undefined) {
            queryParameters.set('filename', <any>filename);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Encrypts the wallet with &#39;passphrase&#39;. This is for first time encryption. After this, any calls that interact with private keys such as sending or signing will require the passphrase to be set prior the making these calls. Use the walletpassphrase call for this, and then walletlock call. If the wallet is already encrypted, use the walletpassphrasechange call. Note that this will shutdown the server.
     * @param request
     */
    public encryptwalletWithHttpInfo(request: EncryptWalletRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/encryptwallet';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling encryptwallet.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED. Returns the account associated with the given address.
     * @param syscoinaddress The syscoin address for account lookup.
     */
    public getaccountWithHttpInfo(syscoinaddress: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getaccount';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'syscoinaddress' is not null or undefined
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling getaccount.');
        }
        if (syscoinaddress !== undefined) {
            queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED. Returns the current Syscoin address for receiving payments to this account.
     * @param account The account name for the address. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.
     */
    public getaccountaddressWithHttpInfo(account: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getaccountaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getaccountaddress.');
        }
        if (account !== undefined) {
            queryParameters.set('account', <any>account);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED. Returns the list of addresses for the given account.
     * @param account
     */
    public getaddressesbyaccountWithHttpInfo(account: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getaddressesbyaccount';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getaddressesbyaccount.');
        }
        if (account !== undefined) {
            queryParameters.set('account', <any>account);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * If account is not specified, returns the server&#39;s total available balance. If account is specified (DEPRECATED), returns the balance in the account. Note that the account \&quot;\&quot; is not the same as leaving the parameter out. The server total may be different to the balance in the default \&quot;\&quot; account.
     * @param account DEPRECATED. The selected account, or \&quot;*\&quot; for entire wallet. It may be the default account using \&quot;\&quot;.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeWatchonly Also include balance in watchonly addresses (see &#39;importaddress&#39;)
     */
    public getbalanceWithHttpInfo(account?: string, minconf?: number, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getbalance';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (account !== undefined) {
            queryParameters.set('account', <any>account);
        }

        if (minconf !== undefined) {
            queryParameters.set('minconf', <any>minconf);
        }

        if (includeWatchonly !== undefined) {
            queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * ï»¿If verbose is false, returns a string that is serialized, hex-encoded data for block &#39;hash&#39;. If verbose is true, returns an Object with information about block &lt;hash&gt;.
     * @param hash
     * @param verbose
     */
    public getblockWithHttpInfo(hash: string, verbose?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getblock';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'hash' is not null or undefined
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling getblock.');
        }
        if (hash !== undefined) {
            queryParameters.set('hash', <any>hash);
        }

        if (verbose !== undefined) {
            queryParameters.set('verbose', <any>verbose);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns an object containing various state info regarding block chain processing.
     */
    public getblockchaininfoWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getblockchaininfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns the number of blocks in the longest block chain.
     */
    public getblockcountWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getblockcount';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns an object containing various state info.
     */
    public getinfoWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getinfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns a json object containing mining-related information.
     */
    public getmininginfoWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getmininginfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns a new Syscoin address for receiving payments. If &#39;account&#39; is specified (DEPRECATED), it is added to the address book so payments received with the address will be credited to &#39;account&#39;.
     * @param request
     */
    public getnewaddressWithHttpInfo(request?: GetNewAddressRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getnewaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns data about each connected network node as a json array of objects.
     */
    public getpeerinfoWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getpeerinfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED. Returns the total amount received by addresses with &lt;account&gt; in transactions with at least [minconf] confirmations.
     * @param account The selected account, may be the default account using \&quot;\&quot;.
     * @param minconf Only include transactions confirmed at least this many times.
     */
    public getreceivedbyaccountWithHttpInfo(account: string, minconf?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getreceivedbyaccount';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getreceivedbyaccount.');
        }
        if (account !== undefined) {
            queryParameters.set('account', <any>account);
        }

        if (minconf !== undefined) {
            queryParameters.set('minconf', <any>minconf);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns the total amount received by the given syscoinaddress in transactions with at least minconf confirmations.
     * @param syscoinaddress The syscoin address for transactions.
     * @param minconf Only include transactions confirmed at least this many times.
     */
    public getreceivedbyaddressWithHttpInfo(syscoinaddress: string, minconf?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getreceivedbyaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'syscoinaddress' is not null or undefined
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling getreceivedbyaddress.');
        }
        if (syscoinaddress !== undefined) {
            queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }

        if (minconf !== undefined) {
            queryParameters.set('minconf', <any>minconf);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Get detailed information about in-wallet transaction &lt;txid&gt;
     * @param txid The transaction id
     * @param includeWatchonly Whether to include watchonly addresses in balance calculation and details[]
     */
    public gettransactionWithHttpInfo(txid: string, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/gettransaction';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'txid' is not null or undefined
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling gettransaction.');
        }
        if (txid !== undefined) {
            queryParameters.set('txid', <any>txid);
        }

        if (includeWatchonly !== undefined) {
            queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns the server&#39;s total unconfirmed balance
     */
    public getunconfirmedbalanceWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getunconfirmedbalance';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns a new Syscoin (starts with 1) address for receiving payments. If &#39;account&#39; is specified (DEPRECATED), it is added to the address book so payments received with the address will be credited to &#39;account&#39;.
     * @param account DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.
     */
    public getv2addressWithHttpInfo(account?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getv2address';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (account !== undefined) {
            queryParameters.set('account', <any>account);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns wallet balance for all accounts. Does not include watch only accounts.
     */
    public getwalletbalanceWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getwalletbalance';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns an object containing various wallet state info.
     */
    public getwalletinfoWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getwalletinfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns a new ZCash address for receiving payments in ZCash transaparent tokens. so payments received with the address will be credited to &#39;account&#39;.
     * @param address
     */
    public getzaddressWithHttpInfo(address: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getzaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getzaddress.');
        }
        if (address !== undefined) {
            queryParameters.set('address', <any>address);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Adds a script (in hex) or address that can be watched as if it were in your wallet but cannot be used to spend.
     * @param request
     */
    public importaddressWithHttpInfo(request: ImportAddressRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/importaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importaddress.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Adds a private key (as returned by dumpprivkey) to your wallet.
     * @param request
     */
    public importprivkeyWithHttpInfo(request: ImportPrivKeyRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/importprivkey';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importprivkey.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Imports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.
     * @param rawtransaction
     * @param txoutproof
     */
    public importprunedfundsWithHttpInfo(rawtransaction: string, txoutproof: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/importprunedfunds';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'rawtransaction' is not null or undefined
        if (rawtransaction === null || rawtransaction === undefined) {
            throw new Error('Required parameter rawtransaction was null or undefined when calling importprunedfunds.');
        }
        // verify required parameter 'txoutproof' is not null or undefined
        if (txoutproof === null || txoutproof === undefined) {
            throw new Error('Required parameter txoutproof was null or undefined when calling importprunedfunds.');
        }
        if (rawtransaction !== undefined) {
            queryParameters.set('rawtransaction', <any>rawtransaction);
        }

        if (txoutproof !== undefined) {
            queryParameters.set('txoutproof', <any>txoutproof);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Adds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend.
     * @param request
     */
    public importpubkeyWithHttpInfo(request: ImportPubKeyRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/importpubkey';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importpubkey.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Imports keys from a wallet dump file (see dumpwallet).
     * @param request
     */
    public importwalletWithHttpInfo(request: ImportWalletRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/importwallet';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importwallet.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED. Returns Object that has account names as keys, account balances as values.
     * @param minconf Only include transactions with at least this many confirmations
     * @param includeWatchonly Include balances in watchonly addresses (see &#39;importaddress&#39;)
     */
    public listaccountsWithHttpInfo(minconf?: number, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/listaccounts';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (minconf !== undefined) {
            queryParameters.set('minconf', <any>minconf);
        }

        if (includeWatchonly !== undefined) {
            queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Lists groups of addresses which have had their common ownership made public by common use as inputs or as the resulting change in past transactions
     */
    public listaddressgroupingsWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/listaddressgroupings';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED. List balances by account.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeempty Whether to include accounts that haven&#39;t received any payments.
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     */
    public listreceivedbyaccountWithHttpInfo(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/listreceivedbyaccount';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (minconf !== undefined) {
            queryParameters.set('minconf', <any>minconf);
        }

        if (includeempty !== undefined) {
            queryParameters.set('includeempty', <any>includeempty);
        }

        if (includeWatchonly !== undefined) {
            queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * List balances by receiving address.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeempty Whether to include accounts that haven&#39;t received any payments.
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     */
    public listreceivedbyaddressWithHttpInfo(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/listreceivedbyaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (minconf !== undefined) {
            queryParameters.set('minconf', <any>minconf);
        }

        if (includeempty !== undefined) {
            queryParameters.set('includeempty', <any>includeempty);
        }

        if (includeWatchonly !== undefined) {
            queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Get all transactions in blocks since block [blockhash], or all transactions if omitted
     * @param blockhash The block hash to list transactions since
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     * @param targetConfirmations
     */
    public listsinceblockWithHttpInfo(blockhash?: string, includeWatchonly?: boolean, targetConfirmations?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/listsinceblock';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (blockhash !== undefined) {
            queryParameters.set('blockhash', <any>blockhash);
        }

        if (includeWatchonly !== undefined) {
            queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }

        if (targetConfirmations !== undefined) {
            queryParameters.set('target-confirmations', <any>targetConfirmations);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Returns up to &#39;count&#39; most recent transactions skipping the first &#39;from&#39; transactions for account &#39;account&#39;.
     * @param account DEPRECATED. The account name. Should be \&quot;*\&quot;.
     * @param count The number of transactions to return
     * @param from The number of transactions to skip
     * @param includeWatchonly Include transactions to watchonly addresses (see &#39;importaddress&#39;)
     */
    public listtransactionsWithHttpInfo(account?: string, count?: number, from?: number, includeWatchonly?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/listtransactions';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (account !== undefined) {
            queryParameters.set('account', <any>account);
        }

        if (count !== undefined) {
            queryParameters.set('count', <any>count);
        }

        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }

        if (includeWatchonly !== undefined) {
            queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED. Move a specified amount from one account in your wallet to another.
     * @param request
     */
    public moveWithHttpInfo(request: MoveRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/move';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling move.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Deletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will effect wallet balances.
     * @param txid
     */
    public removeprunedfundsWithHttpInfo(txid: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/removeprunedfunds';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'txid' is not null or undefined
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling removeprunedfunds.');
        }
        if (txid !== undefined) {
            queryParameters.set('txid', <any>txid);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * DEPRECATED (use sendtoaddress). Sent an amount from an account to a syscoin address. The amount is a real and is rounded to the nearest 0.00000001. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public sendfromWithHttpInfo(request: SendFromRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/sendfrom';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling sendfrom.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Send multiple times. Amounts are double-precision floating point numbers. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public sendmanyWithHttpInfo(request: SendManyRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/sendmany';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling sendmany.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Send an amount to a given address. The amount is a real and is rounded to the nearest 0.00000001. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public sendtoaddressWithHttpInfo(request: SendToAddressRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/sendtoaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling sendtoaddress.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Sign a message with the private key of an address. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request
     */
    public signmessageWithHttpInfo(request: SignMessageRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/signmessage';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling signmessage.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Decode raw syscoin transaction (serialized, hex-encoded) and display information pertaining to the service that is included in the transactiion data output(OP_RETURN)
     * @param alias
     * @param hexstring
     */
    public syscoindecoderawtransactionWithHttpInfo(alias: string, hexstring: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/syscoindecoderawtransaction';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'alias' is not null or undefined
        if (alias === null || alias === undefined) {
            throw new Error('Required parameter alias was null or undefined when calling syscoindecoderawtransaction.');
        }
        // verify required parameter 'hexstring' is not null or undefined
        if (hexstring === null || hexstring === undefined) {
            throw new Error('Required parameter hexstring was null or undefined when calling syscoindecoderawtransaction.');
        }
        if (alias !== undefined) {
            queryParameters.set('alias', <any>alias);
        }

        if (hexstring !== undefined) {
            queryParameters.set('hexstring', <any>hexstring);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Sign inputs for raw transaction (serialized, hex-encoded) and sends them out to the network if signing is complete
     * @param hexstring
     */
    public syscoinsignrawtransactionWithHttpInfo(hexstring: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/syscoinsignrawtransaction';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'hexstring' is not null or undefined
        if (hexstring === null || hexstring === undefined) {
            throw new Error('Required parameter hexstring was null or undefined when calling syscoinsignrawtransaction.');
        }
        if (hexstring !== undefined) {
            queryParameters.set('hexstring', <any>hexstring);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Return information about the given syscoin address.
     * @param syscoinaddress
     */
    public validateaddressWithHttpInfo(syscoinaddress: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/validateaddress';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'syscoinaddress' is not null or undefined
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling validateaddress.');
        }
        if (syscoinaddress !== undefined) {
            queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Verify a signed message
     * @param syscoinaddress The syscoin address to use for the signature.
     * @param signature The signature provided by the signer in base 64 encoding (see signmessage).
     * @param message The message that was signed.
     */
    public verifymessageWithHttpInfo(syscoinaddress: string, signature: string, message: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/verifymessage';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'syscoinaddress' is not null or undefined
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling verifymessage.');
        }
        // verify required parameter 'signature' is not null or undefined
        if (signature === null || signature === undefined) {
            throw new Error('Required parameter signature was null or undefined when calling verifymessage.');
        }
        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling verifymessage.');
        }
        if (syscoinaddress !== undefined) {
            queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }

        if (signature !== undefined) {
            queryParameters.set('signature', <any>signature);
        }

        if (message !== undefined) {
            queryParameters.set('message', <any>message);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Removes the wallet encryption key from memory, locking the wallet. After calling this method, you will need to call walletpassphrase again before being able to call any methods which require the wallet to be unlocked.
     */
    public walletlockWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/walletlock';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Stores the wallet decryption key in memory for &#39;timeout&#39; seconds. This is needed prior to performing transactions related to private keys such as sending syscoins
     * @param request
     */
    public walletpassphraseWithHttpInfo(request: WalletPassphraseRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/walletpassphrase';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling walletpassphrase.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     *
     * Changes the wallet passphrase from &#39;oldpassphrase&#39; to &#39;newpassphrase&#39;.
     * @param request
     */
    public walletpassphrasechangeWithHttpInfo(request: WalletPassphraseChangeRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/walletpassphrasechange';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling walletpassphrasechange.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
